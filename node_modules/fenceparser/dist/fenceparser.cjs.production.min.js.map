{"version":3,"file":"fenceparser.cjs.production.min.js","sources":["../src/utils.ts","../src/Lexer.ts","../src/Parser.ts","../src/index.ts"],"sourcesContent":["export type Token = string | number | boolean\n\nexport const isQuoted = (s: string) => {\n  const first = s[0]\n  const last = s[s.length - 1]\n\n  return s.length > 1 && first === last && (first === '\"' || last === \"'\")\n}\n\nexport class Iterator<T extends string | Array<Token>> {\n  protected error(err: string) {\n    throw new Error(`Fenceparser: ${err}.`)\n  }\n\n  protected start = 0\n  protected current = 0\n\n  protected peek(n?: number): T[number] {\n    return this.input[this.current + (n ?? 0)]\n  }\n\n  protected advance(): T[number] {\n    return this.input[this.current++]\n  }\n\n  protected isAtEnd() {\n    return this.current >= this.input.length\n  }\n\n  public constructor(protected readonly input: T) {}\n}\n","import {Iterator, Token} from './utils'\n\nexport const lex = (input: string) => new Lexer(input).scan()\n\nconst KEYWORDS: Record<string, Token> = {\n  true: true,\n  false: false\n}\n\nconst isAlpha = (s: string) => /[a-zA-Z_$-]/.test(s)\nconst isNumeric = (s: string) => /[0-9]/.test(s)\nconst isAlphaNumeric = (s: string) => isAlpha(s) || isNumeric(s)\n\nclass Lexer extends Iterator<string> {\n  private output: Array<Token> = []\n\n  private string(quote: string) {\n    while (this.peek() !== quote && !this.isAtEnd()) this.advance()\n\n    if (this.isAtEnd()) {\n      this.error('Unterminated string')\n    }\n\n    this.advance()\n    this.output.push(this.input.substring(this.start, this.current))\n  }\n\n  private number() {\n    while (isNumeric(this.peek()) && !this.isAtEnd()) this.advance()\n\n    if (this.peek() === '-' && isNumeric(this.peek(1))) {\n      this.advance()\n      while (isNumeric(this.peek())) this.advance()\n      this.output.push(this.input.substring(this.start, this.current))\n      return\n    } else if (this.peek() === '.' && isNumeric(this.peek(1))) {\n      this.advance()\n      while (isNumeric(this.peek())) this.advance()\n    }\n\n    this.output.push(parseFloat(this.input.substring(this.start, this.current)))\n  }\n\n  private identifier() {\n    while (isAlphaNumeric(this.peek()) && !this.isAtEnd()) this.advance()\n\n    const text = this.input.substring(this.start, this.current)\n    if (Object.keys(KEYWORDS).includes(text)) {\n      this.output.push(KEYWORDS[text])\n    } else {\n      this.output.push(text)\n    }\n  }\n\n  public scan() {\n    while (!this.isAtEnd()) {\n      this.start = this.current\n\n      const next = this.advance()\n      switch (next) {\n        case '{':\n        case '}':\n        case '=':\n        case ',':\n        case ':':\n        case '[':\n        case ']':\n          this.output.push(next)\n          break\n        case '\"':\n        case \"'\":\n          this.string(next)\n          break\n        case ' ':\n        case '\\r':\n        case '\\t':\n        case '\\n':\n          break\n        default:\n          if (isNumeric(next)) {\n            this.number()\n          } else if (isAlpha(next)) {\n            this.identifier()\n          } else {\n            this.error(`Unexpected character ${next}`)\n          }\n      }\n    }\n\n    return this.output\n  }\n}\n","import {isQuoted, Iterator, Token} from './utils'\n\n// Grammar - Recursive Descent\n//\n// MAIN → EXPR*\n// EXPR → OBJECT | IDENTIFIER (= VALUE)?\n//\n// OBJECT → { OBJECT_VALUES? }\n// OBJECT_VALUES → OBJECT_VALUE (, OBJECT_VALUE)*\n// OBJECT_VALUE → NUMBER | IDENTIFIER | (IDENTIFIER | STRING | NUMBER): VALUE\n//\n// ARRAY → [ ARRAY_VALUES? ]\n// ARRAY_VALUES → (ARRAY_VALUE) (ARRAY_VALUE)*\n// ARRAY_VALUE → VALUE\n//\n// VALUE → IDENTIFIER | OBJECT | ARRAY | (\"|') STRING (\"|') | BOOLEAN | NUMBER\n// IDENTIFIER → STRING\n\nexport type OBJECT = {[key in string | number]: VALUE}\nexport type VALUE = OBJECT | Array<VALUE> | string | boolean | number\n\nexport const parse = (input: Array<Token>) => new Parser(input).parse()\n\nclass Parser extends Iterator<Array<Token>> {\n  private output: Record<string, VALUE> = {}\n\n  private object() {\n    const result: OBJECT = {}\n    const parseValue = () => {\n      let identifier = this.advance()\n\n      if (typeof identifier === 'number') {\n        identifier = identifier as number\n      } else if (typeof identifier === 'string' && isQuoted(identifier)) {\n        identifier = identifier.slice(1, -1)\n      }\n      identifier = identifier as string\n\n      if (this.peek() === ':') {\n        this.advance()\n        result[identifier] = this.value()\n      } else {\n        result[identifier] = true\n      }\n    }\n\n    this.advance()\n    if (this.peek() !== '}') {\n      parseValue()\n      while (this.peek() === ',') {\n        this.advance()\n        if (this.peek() === '}') {\n          this.error('Trailing comma')\n        }\n        parseValue()\n      }\n    }\n\n    if (this.advance() !== '}') {\n      this.error('Unterminated object')\n    }\n    return result\n  }\n\n  private array() {\n    const result: Array<VALUE> = []\n\n    this.advance()\n    if (this.peek() !== ']') {\n      result.push(this.value())\n      while (this.peek() === ',') {\n        this.advance()\n        if (this.peek() === ']') {\n          this.error('Trailing comma')\n        }\n        result.push(this.value())\n      }\n    }\n    if (this.advance() !== ']') {\n      this.error('Unterminated array')\n    }\n    return result\n  }\n\n  private value(): VALUE {\n    if (this.peek() === '{') {\n      return this.object()\n    } else if (this.peek() === '[') {\n      return this.array()\n    } else if (\n      typeof this.peek() === 'string' &&\n      isQuoted(this.peek() as string)\n    ) {\n      return (this.advance() as string).slice(1, -1)\n    } else {\n      return this.advance()\n    }\n  }\n\n  public parse() {\n    if (this.input.length < 1) {\n      return null\n    }\n\n    while (!this.isAtEnd()) {\n      const peeked = this.peek()\n\n      if (peeked === '{') {\n        if (!this.output.highlight) {\n          this.output.highlight = {}\n        }\n\n        this.output.highlight = {\n          ...(this.output.highlight as OBJECT),\n          ...this.object()\n        }\n      } else {\n        const identifier = this.advance() as string\n\n        if (this.peek() === '=') {\n          this.advance()\n          this.output[identifier] = this.value()\n        } else {\n          this.output[identifier] = true\n        }\n      }\n    }\n\n    return this.output\n  }\n}\n","import {lex} from './Lexer'\nimport {parse} from './Parser'\n\nexport {lex, parse}\nexport default (input: string) => parse(lex(input))\n"],"names":["isQuoted","s","first","last","length","Iterator","input","error","err","Error","peek","n","this","current","advance","isAtEnd","lex","Lexer","scan","KEYWORDS","isAlpha","test","isNumeric","string","quote","output","push","substring","start","number","parseFloat","identifier","text","Object","keys","includes","next","parse","Parser","object","result","parseValue","_this2","slice","value","array","highlight"],"mappings":"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"}